# GoodCompanyDemo
This is a demo for a prospective employer. The brief was to create an inventory management system for computer infrastructure so that users could view and edit inventory information.

There was no real guidance as to how to build the interface. We were told we could use an advanced framework like Angular or Vue, or just do a simple html form.
As it happened I had been doing a lot of work around integrating SPA frameworks with .NET, so I decided to do an Angualar front-end with a webAPI backend. We were told we could use an in-memory storage solution, so I went with a static service implementation based on the thread-safe ConcurrentBag storage class, which I created as a Singleton. I added service injection, but then had to find a place where the data could be pre-populated at start-up. Obviously this had to happen only once in the life of the application. Attempts to do it in the Startup class were unsuccessful, as it did not seem to be possible to get refererences back from the injected services once they had been created. Perhaps more research would have helped, but there was no time. But since the service was a Singleton, its constructor would only get called once in its lifecycle, so that seemed the obvious place to populate data.

Unfortunately, despite having quite a lot of existing code to hand, there were quite a lot of challenges involved in getting the application to work, and these ended up chewing up a lot of development time, so I could not implement everything I hoped to do. Nonetheless, the fundamental technical challenges were solved, and any additional features would really just have been extensions of the same ideas. I could also have added an interface to edit different pc types, but it's a trivial exercise.

I wrote some server-side unit tests, but did not have time to write client-side ones. I wasted a lot of time trying to get an integration unit test to work, only to conclude that there was nothing wrong with the code - it was just that the approach was unsuitable for testing unpublished SPA applications. I kept getting an error about npm not being in my classpath, even though it apparently is. I decided not to waste any more time on it.

The major challenge was to support a variety of different computer types. I created a parent class that stored all common properties, and inherited from it for computers with more specific requirements.

That created a problem, though. I needed to know if I could communicate with the server backend by only specifying the parent class. This is known in the trade as "boxing" - you store an item as an instance of a more general class, or even in a generic container that does not have any knowledge of the class. You then have to "unbox" - dynamically cast the object back to its specific class when you get a response. The worry I had was that I would find that my class parameters were truncated by the operation. I would only be able to get the parent class properties back, and the sub-class properties would be discarded by the POST operation over the internet.

I wrote a set of xunit unit tests to examine this issue, and was gratified to discover, from the point of view of .NET, that the boxing and unboxing operations worked even when being invoked by a service. I assumed I had solved the issue. But it's a good example of how even a unit test can blind-side you: the same operation did not work when I invoked the service from the JS front-end. The truncation I had feared was very much in evidence. I also found it very difficult to POST to webAPI from the front-end, and ran into obscure issues relating to JSON serialisation. I had to install the Newtonsoft JSON parser to get the operation to work. Other people on the Internet did not seem to be encountering this problem, which confused me, but then other people did. The error message I was geting was contracitory and unhelpful.

In the end, the work-around was to create a cludgy generic class that contained every conceivable property, and then create child classes for storage by checking the typeName property. Not the cool solution I had hoped for. If I had time, I would have looked at just passing in an Object parameter, and then using a Factory method to spawn the required class, and using reflection to loop through the child class properties and map them onto whatever properties were populated in the Object.

I have experimented with Factory methods written in other languages like Java, but unfortunately some of the cool things you can do with template return types don't seem to work in C#, so the corresponding implementation in C# tends to be rather disapointing, involving a lot of hard-coding of classes via switch statements that you might hope you could automate.

Another thing - you have to replicate your classes in both the back-end and front-end frameworks. It would be great if you could somehow spawn JS or TS classes from a .NET definition, but I can't see any obvious way of doing it. In the end, I suppose the moral is that there is no one-stop shop for data storage - there is always going to be a far amound of hard coding and schema definitions. The trick is to create an extensible system that can be easily extended when new requirements are added.

A big annoyance to me with .NET is that because MS keep releasing new versions in less than a year, there's a huge amount of unreliable information floating around on the internet. When I was having trouble capturing the POST parameter, some initial research I did led me to think my controller implementation was out-of-date. But then I realised it was the other way around. I was reading an old article, and it wasn't identifying the cause of my problem. webAPI used to be a distinct technology from MVC, but now it has been subsumed into the general MVC platform, and is just another type of controller.

The Angular implementation is not going to win any prizes, but it's quite well written, and uses a good variety of techniques - service injection, some inheritance, routing, subscribing to Observables, redirecting, and reactive forms.

I didn't have time to look at modules, but it's probably too small a project to benefit from them. A major annoyance - the new Angular CLI is now module-aware by default and keeps crashing saying it can't find a suitable module to house your component when you try to create one.

There are other techniques like lazy-loading, but these are probably beyond the scope of a simple project like this. I could have used the Material library for databinding, but it would have been overkill.

One major annoyance was discovering that there is no built-in way of reading a select form control in Angular. You have to use a rather cludgy work-around triggered by the control's change event. That means yo have to hard-code the initial value of the control, which seems very limited, an makes it difficult to create the control dynamically from a service, which is what I was originally hoping to do.

